options{
STATIC = false;
LOOKAHEAD = 3;
FORCE_LA_CHECK = true;
}
PARSER_BEGIN(Compiler)

    package com.cc.gracecompiler.parser;
    import java.io.*;
    import com.cc.gracecompiler.classes.*;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.LinkedList;
    import java.util.Stack;

    public class Compiler{

        public static Stack<Escopo> pilhaDeEscopos = new Stack<Escopo>();

        public static void main(String args[]) throws ParseException{

            try {

                FileInputStream file = new FileInputStream(args[0]);
                Compiler analyzer = new Compiler(file);
                analyzer.programa();
                System.out.println("Compiler execution completed");

            }catch(Throwable e){
                System.out.println(e.getMessage()); //Mensagem de erro léxico (em ingles) mostrando linha e coluna
                System.out.println("Errors detected");
                e.printStackTrace();
            }
        }
    }

PARSER_END(Compiler)

TOKEN_MGR_DECLS:{ //CONTADOR DE ERROS
        int countLexError = 0;
        public int foundLexError(){
            return countLexError;
        }
}


TOKEN:{ //PALAVRAS RESERVADAS

    <BOOL: "bool">{System.out.println("Reserved word: "+image);}    //1
    |<DEF: "def">{System.out.println("Reserved word: "+image);} //2
    |<ELSE: "else">{System.out.println("Reserved word: "+image);}   //3
    |<FOR: "for">{System.out.println("Reserved word: "+image);} //4
    |<IF: "if">{System.out.println("Reserved word: "+image);}   //5
    |<INT: "int">{System.out.println("Reserved word: "+image);} //6
    |<READ: "read">{System.out.println("Reserved word: "+image);} //7
    |<RETURN: "return">{System.out.println("Reserved word: "+image);} //8
    |<CONTINUE: "skip">{System.out.println("Reserved word: "+image);} //9
    |<STOP: "stop">{System.out.println("Reserved word: "+image);} //10
    |<STRING: "string">{System.out.println("Reserved word: "+image);}   //11
    |<VAR: "var">{System.out.println("Reserved word: "+image);} //12
    |<WHILE: "while">{System.out.println("Reserved word: "+image);} //13
    |<WRITE: "write">{System.out.println("Reserved word: "+image);} //14
    |<VOID:"void">{System.out.println("Reserved word: "+image);}    //15
}

TOKEN:{ //SÍMBOLOS
    <LPARENTHESIS: "(">{System.out.println("Symbol: "+image);}  //16
    |<RPARENTHESIS: ")">{System.out.println("Symbol: "+image);} //17
    |<LBRACKET: "[">{System.out.println("Symbol: "+image);} //18
    |<RBRACKET: "]">{System.out.println("Symbol: "+image);} //19
    |<LKEYS: "{">{System.out.println("Symbol: "+image);} //20
    |<RKEYS: "}">{System.out.println("Symbol: "+image);} //21
    |<COMMA: ",">{System.out.println("Symbol: "+image);} //22
    |<SEMICOLON: ";">{System.out.println("Symbol: "+image);} //23
    |<QUOTE: "\"">{System.out.println("Symbol: "+image);} //24
    |<PLUS: "+">{System.out.println("Symbol: "+image);} //25
    |<MINUS: "-">{System.out.println("Symbol: "+image);} //26
    |<TIMES: "*">{System.out.println("Symbol: "+image);} //27
    |<DIVISION: "/">{System.out.println("Symbol: "+image);} //28
    |<PERCENT: "%">{System.out.println("Symbol: "+image);} //29
    |<EQUALS: "==">{System.out.println("Symbol: "+image);} //30
    |<DIFFERENT: "!=">{System.out.println("Symbol: "+image);} //31
    |<BIGGEREQUAL: ">=">{System.out.println("Symbol: "+image);} //32
    |<BIGGER: ">">{System.out.println("Symbol: "+image);} //33
    |<SMALLEREQUAL: "<=">{System.out.println("Symbol: "+image);} //34
    |<SMALLER: "<">{System.out.println("Symbol: "+image);} //35
    |<OR: "||">{System.out.println("Symbol: "+image);} //36
    |<AND: "&&">{System.out.println("Symbol: "+image);} //37
    |<NEGATION: "!">{System.out.println("Symbol: "+image);} //38
    |<PLUSEQUAL: "+=">{System.out.println("Symbol: "+image);} //39
    |<MINUSEQUAL: "-=">{System.out.println("Symbol: "+image);} //40
    |<ASTERISKEQUAL: "*=">{System.out.println("Symbol: "+image);} //41
    |<DIVISIONEQUAL: "/=">{System.out.println("Symbol: "+image);} //42
    |<PERCENTEQUAL: "%=">{System.out.println("Symbol: "+image);} //43
    |<ATTRIBUTION: "=">{System.out.println("Symbol: "+image);} //44
    |<QUESTION: "?">{System.out.println("Symbol: "+image);} //45
    |<COLON: ":">{System.out.println("Symbol: "+image);} //46
}

TOKEN:{ //PRIMITIVOS
    <NUMBER: ["0"-"9"] (["0"-"9"])* >{System.out.println("Number: "+image);} //47
    |<BOOLEAN: "true" | "false"> {System.out.println("Boolean: "+image);} //48
    |<WORD: <QUOTE> (~["\""])* <QUOTE>>{System.out.println("Word: "+image);} //49
    |<IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "0"-"9", "_"])*>{System.out.println("Identifier: "+image);} //50
}

SKIP:{ // TOKENS IGNORADOS
     " "
    | "\r"
    | "\t"
    | "\n"
    | <COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

/*       TOKEN: { <OPEN_STRING: "\"">{System.out.println("Open String: "+image);}: WORD }
<WORD> TOKEN: { <STRING_BODY: ("\\\\" | "\\\"" | ~["\"", "\\"])+>{System.out.println("String Body: "+image);} }
<WORD> TOKEN: { <CLOSE_STRING: "\"">{System.out.println("Close String: "+image);}: DEFAULT }*/

/*SPECIAL_TOKEN:{
<INVALIDO_LEXICO:(~[" ","\t","\n","\r","\f"])+>
{
    countLexError++;
    System.err.println("Linha " + input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+
    " Token invalido encontrado: " + image + " "+"TOTAL DE ERROS "+countLexError);
    System.out.println("Erro Lexico ------> "+image);
}
}*/


/////////////////////////////////////////////////////PROGRAMA
void programa():
{
    Escopo e = new Escopo(null);
    Compiler.pilhaDeEscopos.push(e);
}
{
    ((decVar())* (decSub())* <EOF>)
    {
        e = Compiler.pilhaDeEscopos.pop();
        e.imprimeTabela();
    }
}

/////////////////////////////////////////////////////DECLARAÇÃO DE VARIÁVEL
void decVar():
{
    Tipo td;
    List<Variavel> vars = new ArrayList<Variavel>();
}
{
    (<VAR> vars = listaSpecVars() <COLON> td = tipo() <SEMICOLON>)
    {
        for(Variavel var : vars){
            var.tipo = td;

            Compiler.pilhaDeEscopos.peek().inserirSimbolo(var.token, var);
        }
        System.out.println("ola decvar");
    }
}

List<Variavel> listaSpecVars():
{
    List<Variavel> vars = new ArrayList<Variavel>();
    Variavel var = null;
}
{

    (var = specVar(){vars.add(var);} (<COMMA>  var = specVar(){vars.add(var);})*)
    {
        System.out.println("ola listaspecvars");
        return vars;
    }
}

Tipo tipo():
{
}
{
    (<WORD>){return Tipo.WORD;}
    |(<INT>){return Tipo.INT;}
    |(<BOOL>){return Tipo.BOOL;}
}

Tipo tipoRetSub():
{
}
{
    (<WORD>){return Tipo.WORD;}
    |(<INT>){return Tipo.INT;}
    |(<BOOL>){return Tipo.BOOL;}
    |(<VOID>){return Tipo.VOID;}
}

///////////////////////////////////////////////////////////// FATORAÇÃO A ESQUERDA
Variavel specVar():
{
    Variavel var = new Variavel();
}
{
    (var.token = <IDENTIFIER>(var.arranjo = specVarArranjo() | specVarSimplesInit())?){
        System.out.println("ola specvar");
        return var;
    }
}


void specVarSimplesInit():
{}
{
    <ATTRIBUTION> expressao()
}

Boolean specVarArranjo():
{}{
    (<LBRACKET> expressao() <RBRACKET> (specVarArranjoInit())? )
    {
        System.out.println("ola specvararranjo");
        return true;
    }
}

void specVarArranjoInit():
{}
{
    <ATTRIBUTION> valorArranjo()
}

void valorArranjo():
{}
{
    <LKEYS>(valorArranjoNumber()|valorArranjoBoolean()|valorArranjoString())<RKEYS>
}

void valorArranjoNumber():
{}
{
    <NUMBER> (<COMMA> valorArranjoNumber())?
}

void valorArranjoBoolean():
{}
{
    <BOOLEAN> (<COMMA> valorArranjoBoolean())?
}
void valorArranjoString():
{}
{
    <WORD> (<COMMA> valorArranjoString())?
}


/////////////////////////////////////////////////////////////DECLARAÇÃO DE SUBPROGRAMAS
void decSub():
{
    SubPrograma sub = new SubPrograma();
    Tipo tipo;
    List<Variavel> listaParametros = new ArrayList<Variavel>();

}
{
    (<DEF> sub.token = <IDENTIFIER> <LPARENTHESIS> (listaParametros = listaParametros())? <RPARENTHESIS> (tipo = decFunc() | tipo = decProc()))
    {
        sub.tipo = tipo;
        sub.listaParametros = listaParametros;

        Compiler.pilhaDeEscopos.peek().inserirSimbolo(sub.token, sub);

    }
    //decProc() | decFunc()
}

Tipo decProc():
{}
{
    (bloco())
    {
        return Tipo.VOID;
    }
    //<DEF> <IDENTIFIER> <LPARENTHESIS> (listaParametros()) <RPARENTHESIS> bloco()
}

Tipo decFunc():
{
    Tipo aux;

}
{
    (<COLON> aux = tipoRetSub() bloco())
    {
        return aux;
    }
    //<DEF> <IDENTIFIER> <LPARENTHESIS> (listaParametros()) <RPARENTHESIS> tipo() bloco()
}

/////////////////////////////////////////////////////////////LISTA DE PARÂMETROS
List<Variavel> listaParametros():
{

    List<Variavel> paramList = new ArrayList<Variavel>();
    List<Variavel> auxList = null;

}
{
    ((auxList = specParams()){ paramList.addAll(auxList); } (<SEMICOLON> (auxList = specParams()){paramList.addAll(auxList);})*)
    {
        return paramList;
    }
}

List<Variavel> specParams():
{
    List<Variavel> paramList = new ArrayList<Variavel>();
    Variavel var = null;
    Tipo td;

}
{
    ((var = param()){paramList.add(var);} (<COMMA>  (var=param()){paramList.add(var);} )* <COLON> td=tipo())
    {
        for(Variavel param: paramList){
            param.tipo = td;
        }
        return paramList;
    }
}

Variavel param():
{

    Variavel param = new Variavel();
    Boolean isArranjo = false;

}
{
    //<IDENTIFIER> | <IDENTIFIER> <LBRACKET><RBRACKET>
    (param.token = <IDENTIFIER> ((<LBRACKET><RBRACKET>){ isArranjo = true;})?){
        param.arranjo = isArranjo;
        return param;
    }
}

/////////////////////////////////////////////////////////////COMANDOS SIMPLES E BLOCOS DE COMANDOS
void comando():
{}
{
    cmdSimples() | bloco()
}

void cmdSimples():
{}{
    <IDENTIFIER>(cmdAtrib()<SEMICOLON> | cmdChamadaProc()) | cmdIf() | cmdWhile() | cmdFor() | cmdStop() | cmdSkip() |
    cmdReturn() | /*cmdChamadaProc() |*/ cmdRead() | cmdWrite()
}

void bloco():
{

    Escopo e = new Escopo( Compiler.pilhaDeEscopos.peek() );
    Compiler.pilhaDeEscopos.push(e);

}
{
    (<LKEYS> (decVar())* (decSub())* (comando())* <RKEYS>)
    {
        Compiler.pilhaDeEscopos.peek().imprimeTabela();       //IMPRIMIR TABELA
        Compiler.pilhaDeEscopos.pop();
    }
}

/////////////////////////////////////////////////////////////ATRIBUIÇÃO
void cmdAtrib():
{}
{
    atrib()
}

void atrib():
{

}
{
    variavel() ((<ATTRIBUTION> | <PLUSEQUAL> | <MINUSEQUAL> | <ASTERISKEQUAL> | <DIVISIONEQUAL> | <PERCENTEQUAL>) expressao() | <PLUS><PLUS> | <MINUS><MINUS> | <TIMES><TIMES> | <DIVISION><DIVISION>)

}

/////////////////////////////////////////////////////////////CONDICIONAL IF
void cmdIf():
{}
{
    <IF> <LPARENTHESIS> expressao() <RPARENTHESIS> comando() (<ELSE> comando())?
}

/////////////////////////////////////////////////////////////COMANDO WHILE
void cmdWhile():
{}
{
    <WHILE> <LPARENTHESIS> expressao() <RPARENTHESIS> comando()
}

/////////////////////////////////////////////////////////////LAÇO FOR
void cmdFor():
{}
{
    <FOR> <LPARENTHESIS> <IDENTIFIER> atrib() <SEMICOLON> expressao() <SEMICOLON> <IDENTIFIER> atrib() <RPARENTHESIS> comando()
}

/////////////////////////////////////////////////////////////INTERRUPÇÃO DE LAÇO
void cmdStop():
{}
{
    <STOP><SEMICOLON>
}

/////////////////////////////////////////////////////////////SALTO DE ITERAÇÃO DE LAÇO
void cmdSkip():
{}
{
    <CONTINUE><SEMICOLON>
}

/////////////////////////////////////////////////////////////RETORNO DE SUBPROGRAMA
void cmdReturn():
{}
{
    <RETURN> (expressao())? <SEMICOLON>
}

/////////////////////////////////////////////////////////////CHAMADA DE PROCEDIMENTO
void cmdChamadaProc():
{}
{
    /*<IDENTIFIER>*/ <LPARENTHESIS> (expressao() (<COMMA> expressao())?)? <RPARENTHESIS> <SEMICOLON>
}

/////////////////////////////////////////////////////////////ENTRADA READ
void cmdRead():
{}
{
    <READ> <IDENTIFIER> variavel() <SEMICOLON>
}

/////////////////////////////////////////////////////////////SAIDA WRITE
void cmdWrite():
{}
{
    <WRITE> expressao() (<COMMA> expressao())* <SEMICOLON>
}

void variavel():
{}
{
    /*<IDENTIFIER>*/ (variavelPartTwo())?
}

void variavelPartTwo():
{}
{
    <LBRACKET> expressao() <RBRACKET>
}


//////////////////////////////////////////////////////////// EXPRESSÁO

//SEGUNDA SINTAXE

void expressao():
{}
{
    orexp()
}

/*void condexp():
{}
{
    orexp() [ <QUESTION> expressao() <COLON> condexp() ]
}*/

void orexp():
{}
{
    andexp() <OR> andexp() | andexp()
}

void andexp():
{}
{
    equalityexp() <AND> equalityexp() | equalityexp()
}

void equalityexp():
{}
{
    relationalexp() (<EQUALS> | <DIFFERENT>) relationalexp() | relationalexp()
}

void relationalexp():
{}
{
    mulexp() (<BIGGEREQUAL> | <BIGGER> | <SMALLEREQUAL> | <SMALLER>) mulexp() | mulexp()
}

void mulexp():
{}
{
    rootexp() (<TIMES> | <DIVISION> | <PERCENT>) rootexp() | rootexp()
}

//void mulexp():
//{}
//{
//    //mulexp() (<TIMES> | <DIVISION> | <PERCENT>) rootexp() | rootexp()
//    rootexp() mulexp2()
//}
//
//void mulexp2():
//{}
//{
//    ((<TIMES> | <DIVISION> | <PERCENT>) rootexp() mulexp2())?
//}

void rootexp():
{}
{
    <LPARENTHESIS> expressao() <RPARENTHESIS> | unaryexp()
}

void unaryexp():
{}
{
    (<PLUS> | <MINUS> | <NEGATION>) primaryexp()
}

void primaryexp():
{}
{
    literal() | nome()
}

void literal():
{
    Token token = null;
}
{
    (token = <NUMBER> | token = <BOOL> | token = <WORD>)
    {
        //return Tipo.getTipo(token.kind);
    }
}

void nome():
{
    Token token;
    Identificavel var = null;
}
{
    (token = <IDENTIFIER> ( (<LBRACKET> expressao() <RBRACKET>) | cmdChamadaProc() )? )
    {
        /*var = Compiler.pilhaDeEscopos.peek().buscarSimbolo(token);
        if(var==null){
            throw new RuntimeException("ERRO: Identificavel " + token.image + " nao instanciado. \r\nLine: " + token.beginLine);
        }

        if(var.getTipo() == Tipo.VOID) throw new RuntimeException("ERRO: Subprograma " + token.image + " nao possui valor de retorno (tipo VOID). \r\nLine: " + token.beginLine);

        return var.getTipo();*/
    }
}

//PRIMEIRA SINTAXE
/*
void operadorTern():
{}
{
    expressao() <QUESTION> expressao() <COLON> expressao()
}

void expressao() :
{}
{
    LogicalOR() //asdasdsd
}

void LogicalOR() : {}
{
    LogicalAND() ( <OR> LogicalAND())*
}

void LogicalAND() : {}
{
    EqualityExpression() ( <AND> EqualityExpression())*
}

void EqualityExpression() : {}
{
    RelativeExpression() (( <EQUALS> | <DIFFERENT> ) RelativeExpression())?
}

void RelativeExpression() :
{}
{
    (AdditiveExpression() ( ( <MINUSEQUAL> | <SMALLER> | <BIGGEREQUAL> | <BIGGER> ) AdditiveExpression())?)
    {

    }
}

void AdditiveExpression() :
{}
{
    (MultiplicativeExpression() ( ( <PLUS> |<MINUS> ) MultiplicativeExpression() )*)
    {

    }
}

void MultiplicativeExpression() :
{}
{
    ( UnaryExpression() ( (  <TIMES> |  <DIVISION> | <PERCENT> ) UnaryExpression() )*)
    {

    }
}

void UnaryExpression() :
{}
{
    (<NEGATION>| <MINUS>)? (<LPARENTHESIS>  expressao() <RPARENTHESIS> | NumberOrBool() | SubCallOrIdentifier())
    {

    }
}

void SubCallOrIdentifier():
{}
{
    <IDENTIFIER> SubCallOrIdentifierPartTwo()// APENAS CHAMADA DE FUNÇAO E CONSIDERADA EXPRESSAO
}


void SubCallOrIdentifierPartTwo():{}
{
    cmdChamadaProc() | (<LBRACKET> expressao() <RBRACKET>)?  // APENAS CHAMADA DE FUNÇAO E CONSIDERADA EXPRESSAO
}

void NumberOrBool() :
{}
{
    //[<MINUS> | <NEGATION>] (<NUMBER> | <BOOL>)
    Number() | Bool() | Word()
}

void Number():
{}
{
    <NUMBER>
}

void Bool():
{}
{
    <BOOLEAN>
}

void Word():
{}
{
    <WORD>
}*/