options{
STATIC = false;
LOOKAHEAD = 3;
FORCE_LA_CHECK = true;
}
PARSER_BEGIN(Compiler)

    package com.cc.gracecompiler.parser;
    import java.io.*;
    import com.cc.gracecompiler.classes.*;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.LinkedList;
    import java.util.Stack;

    public class Compiler{

        public static Stack<Escopo> pilhaDeEscopos = new Stack<Escopo>();

        public static void main(String args[]) throws ParseException{

            try {

                FileInputStream file = new FileInputStream(args[0]);
                Compiler analyzer = new Compiler(file);
                analyzer.programa();
                System.out.println("Compiler execution completed");

            }catch(Throwable e){
                System.out.println(e.getMessage()); //Mensagem de erro léxico (em ingles) mostrando linha e coluna
                System.out.println("Errors detected");
                e.printStackTrace();
            }
        }
    }

PARSER_END(Compiler)

TOKEN_MGR_DECLS:{ //CONTADOR DE ERROS
        int countLexError = 0;
        public int foundLexError(){
            return countLexError;
        }
}


TOKEN:{ //PALAVRAS RESERVADAS

    <BOOL: "bool">              //{System.out.println("Reserved word: "+image);} //1
    |<DEF: "def">               //{System.out.println("Reserved word: "+image);} //2
    |<ELSE: "else">             //{System.out.println("Reserved word: "+image);} //3
    |<FOR: "for">               //{System.out.println("Reserved word: "+image);} //4
    |<IF: "if">                 //{System.out.println("Reserved word: "+image);} //5
    |<INT: "int">               //{System.out.println("Reserved word: "+image);} //6
    |<READ: "read">             //{System.out.println("Reserved word: "+image);} //7
    |<RETURN: "return">         //{System.out.println("Reserved word: "+image);} //8
    |<CONTINUE: "skip">         //{System.out.println("Reserved word: "+image);} //9
    |<STOP: "stop">             //{System.out.println("Reserved word: "+image);} //10
    |<STRING: "string">         //{System.out.println("Reserved word: "+image);} //11
    |<VAR: "var">               //{System.out.println("Reserved word: "+image);} //12
    |<WHILE: "while">           //{System.out.println("Reserved word: "+image);} //13
    |<WRITE: "write">           //{System.out.println("Reserved word: "+image);} //14
    |<VOID:"void">              //{System.out.println("Reserved word: "+image);} //15
}

TOKEN:{ //SÍMBOLOS
    <LPARENTHESIS: "(">         //{System.out.println("Symbol: "+image);}  //16
    |<RPARENTHESIS: ")">        //{System.out.println("Symbol: "+image);} //17
    |<LBRACKET: "[">            //{System.out.println("Symbol: "+image);} //18
    |<RBRACKET: "]">            //{System.out.println("Symbol: "+image);} //19
    |<LKEYS: "{">               //{System.out.println("Symbol: "+image);} //20
    |<RKEYS: "}">               //{System.out.println("Symbol: "+image);} //21
    |<COMMA: ",">               //{System.out.println("Symbol: "+image);} //22
    |<SEMICOLON: ";">           //{System.out.println("Symbol: "+image);} //23
    |<QUOTE: "\"">              //{System.out.println("Symbol: "+image);} //24
    |<PLUS: "+">                //{System.out.println("Symbol: "+image);} //25
    |<MINUS: "-">               //{System.out.println("Symbol: "+image);} //26
    |<TIMES: "*">               //{System.out.println("Symbol: "+image);} //27
    |<DIVISION: "/">            //{System.out.println("Symbol: "+image);} //28
    |<PERCENT: "%">             //{System.out.println("Symbol: "+image);} //29
    |<EQUALS: "==">             //{System.out.println("Symbol: "+image);} //30
    |<DIFFERENT: "!=">          //{System.out.println("Symbol: "+image);} //31
    |<BIGGEREQUAL: ">=">        //{System.out.println("Symbol: "+image);} //32
    |<BIGGER: ">">              //{System.out.println("Symbol: "+image);} //33
    |<SMALLEREQUAL: "<=">       //{System.out.println("Symbol: "+image);} //34
    |<SMALLER: "<">             //{System.out.println("Symbol: "+image);} //35
    |<OR: "||">                 //{System.out.println("Symbol: "+image);} //36
    |<AND: "&&">                //{System.out.println("Symbol: "+image);} //37
    |<NEGATION: "!">            //{System.out.println("Symbol: "+image);} //38
    |<PLUSEQUAL: "+=">          //{System.out.println("Symbol: "+image);} //39
    |<MINUSEQUAL: "-=">         //{System.out.println("Symbol: "+image);} //40
    |<ASTERISKEQUAL: "*=">      //{System.out.println("Symbol: "+image);} //41
    |<DIVISIONEQUAL: "/=">      //{System.out.println("Symbol: "+image);} //42
    |<PERCENTEQUAL: "%=">       //{System.out.println("Symbol: "+image);} //43
    |<ATTRIBUTION: "=">         //{System.out.println("Symbol: "+image);} //44
    |<QUESTION: "?">            //{System.out.println("Symbol: "+image);} //45
    |<COLON: ":">               //{System.out.println("Symbol: "+image);} //46
}

TOKEN:{ //PRIMITIVOS
    <NUMBER: ["0"-"9"] (["0"-"9"])* >{System.out.println("Number: "+image);} //47
    |<BOOLEAN: "true" | "false"> {System.out.println("Boolean: "+image);} //48
    |<WORD: <QUOTE> (~["\""])* <QUOTE>>{System.out.println("Word: "+image);} //49
    |<IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "0"-"9", "_"])*>{System.out.println("Identifier: "+image);} //50
}

SKIP:{ // TOKENS IGNORADOS
     " "
    | "\r"
    | "\t"
    | "\n"
    | <COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

/*       TOKEN: { <OPEN_STRING: "\"">{System.out.println("Open String: "+image);}: WORD }
<WORD> TOKEN: { <STRING_BODY: ("\\\\" | "\\\"" | ~["\"", "\\"])+>{System.out.println("String Body: "+image);} }
<WORD> TOKEN: { <CLOSE_STRING: "\"">{System.out.println("Close String: "+image);}: DEFAULT }*/

/*SPECIAL_TOKEN:{
<INVALIDO_LEXICO:(~[" ","\t","\n","\r","\f"])+>
{
    countLexError++;
    System.err.println("Linha " + input_stream.getEndLine()+" Coluna "+ input_stream.getEndColumn()+
    " Token invalido encontrado: " + image + " "+"TOTAL DE ERROS "+countLexError);
    System.out.println("Erro Lexico ------> "+image);
}
}*/


/////////////////////////////////////////////////////PROGRAMA
void programa():
{
    Escopo e = new Escopo(null);
    Compiler.pilhaDeEscopos.push(e);
}
{
    ((decVar())* (decSub())* <EOF>)
    {
        e = Compiler.pilhaDeEscopos.pop();
        //e.imprimeTabela();
    }
}

/////////////////////////////////////////////////////DECLARAÇÃO DE VARIÁVEL
void decVar():
{
    Tipo td;
    List<Variavel> vars = new ArrayList<Variavel>();
}
{
    (<VAR> vars = listaSpecVars() <COLON> td = tipo() <SEMICOLON>)
    {

        for(Variavel var : vars){
            var.tipo = td;

            Compiler.pilhaDeEscopos.peek().inserirSimbolo(var.token, var);
        }

    }
}

List<Variavel> listaSpecVars():
{
    List<Variavel> vars = new ArrayList<Variavel>();
    Variavel var = null;
}
{

    (var = specVar(){vars.add(var);} (<COMMA>  var = specVar(){vars.add(var);})*)
    {

        return vars;
    }
}

Tipo tipo():
{
}
{
    (<WORD>){return Tipo.WORD;}
    |(<INT>){return Tipo.INT;}
    |(<BOOL>){return Tipo.BOOL;}
}

Tipo tipoRetSub():
{
}
{
    (<WORD>){return Tipo.WORD;}
    |(<INT>){return Tipo.INT;}
    |(<BOOL>){return Tipo.BOOL;}
    |(<VOID>){return Tipo.VOID;}
}

///////////////////////////////////////////////////////////// FATORAÇÃO A ESQUERDA
Variavel specVar():
{
    Variavel var = new Variavel();
}
{
    (var.token = <IDENTIFIER> (var.arranjo = specVarArranjo() | specVarSimplesInit())?){

        return var;
    }
}


Tipo specVarSimplesInit():
{
    Expressao exp = null;
}
{
    (<ATTRIBUTION> exp = expressao())
    {
        return exp.tipo;
    }
}

Boolean specVarArranjo():
{}{
    (<LBRACKET> expressao() <RBRACKET> (specVarArranjoInit())? )
    {
        return true;
    }
}

void specVarArranjoInit():
{}
{
    <ATTRIBUTION> valorArranjo()
}

void valorArranjo():
{}
{
    <LKEYS>(valorArranjoNumber()|valorArranjoBoolean()|valorArranjoString())<RKEYS>
}

void valorArranjoNumber():
{}
{
    <NUMBER> (<COMMA> valorArranjoNumber())?
}

void valorArranjoBoolean():
{}
{
    <BOOLEAN> (<COMMA> valorArranjoBoolean())?
}
void valorArranjoString():
{}
{
    <WORD> (<COMMA> valorArranjoString())?
}


/////////////////////////////////////////////////////////////DECLARAÇÃO DE SUBPROGRAMAS
void decSub():
{
    Escopo e = null;
    SubPrograma sub = new SubPrograma();
    Tipo tipo = Tipo.VOID;
    List<Variavel> listaParametros = new ArrayList<Variavel>();

}
{
    ((<DEF> sub.token = <IDENTIFIER> <LPARENTHESIS> (listaParametros = listaParametros())? <RPARENTHESIS> (<COLON> tipo = tipoRetSub())?){ Compiler.pilhaDeEscopos.peek().inserirSimbolo(sub.token, sub);} e = bloco(listaParametros) )
    {
        sub.tipo = tipo;
        sub.listaParametros = listaParametros;
        //sub.escopo = e;

        Compiler.pilhaDeEscopos.peek().inserirSimbolo(sub.token, sub);

    }
    //decProc() | decFunc()
}

//Tipo decProc():
//{}
//{
//    (bloco())
//    {
//        return Tipo.VOID;
//    }
//    //<DEF> <IDENTIFIER> <LPARENTHESIS> (listaParametros()) <RPARENTHESIS> bloco()
//}
//
//Tipo decFunc():
//{
//    Tipo aux;
//
//}
//{
//    (<COLON> aux = tipoRetSub() bloco())
//    {
//        return aux;
//    }
//    //<DEF> <IDENTIFIER> <LPARENTHESIS> (listaParametros()) <RPARENTHESIS> tipo() bloco()
//}

/////////////////////////////////////////////////////////////LISTA DE PARÂMETROS
List<Variavel> listaParametros():
{

    List<Variavel> paramList = new ArrayList<Variavel>();
    List<Variavel> auxList = null;

}
{
    ((auxList = specParams()){ paramList.addAll(auxList); } (<SEMICOLON> (auxList = specParams()){paramList.addAll(auxList);})*)
    {
        return paramList;
    }
}

List<Variavel> specParams():
{
    List<Variavel> paramList = new ArrayList<Variavel>();
    Variavel var = null;
    Tipo td;

}
{
    ((var = param()){paramList.add(var);} (<COMMA>  (var=param()){paramList.add(var);} )* <COLON> td=tipo())
    {
        for(Variavel param: paramList){
            param.tipo = td;
        }
        return paramList;
    }
}

Variavel param():
{

    Variavel param = new Variavel();
    Boolean isArranjo = false;

}
{
    //<IDENTIFIER> | <IDENTIFIER> <LBRACKET><RBRACKET>
    (param.token = <IDENTIFIER> ((<LBRACKET><RBRACKET>){ isArranjo = true;})?){
        param.arranjo = isArranjo;
        return param;
    }
}

/////////////////////////////////////////////////////////////COMANDOS SIMPLES E BLOCOS DE COMANDOS
void comando():
{}
{
    cmdSimples() | bloco(new ArrayList<Variavel>())
}

void cmdSimples():
{}{
    <IDENTIFIER> ( cmdAtrib() | cmdChamadaProc() ) | cmdIf() | cmdWhile() | cmdFor() | cmdStop() | cmdSkip() |
    cmdReturn() | /*cmdChamadaProc() |*/ cmdRead() | cmdWrite()
}

Escopo bloco(List<Variavel> listaParametros):
{

    Escopo e = new Escopo( Compiler.pilhaDeEscopos.peek() );

    // adicione a lista de parametros aa tabela do escopo
    for(Variavel v : listaParametros){
        e.inserirSimbolo(v.token, v);
    }

    Compiler.pilhaDeEscopos.push(e);

    //e.imprimeTabela();

}
{
    (<LKEYS> (decVar())* (decSub())* (comando())* <RKEYS>)
    {
        Compiler.pilhaDeEscopos.pop();

        return e;
    }
}

/////////////////////////////////////////////////////////////ATRIBUIÇÃO
void cmdAtrib():
{}
{
    atrib() <SEMICOLON>
}

void atrib():
{

}
{
    variavel() (<ATTRIBUTION> | <PLUSEQUAL> | <MINUSEQUAL> | <ASTERISKEQUAL> | <DIVISIONEQUAL> | <PERCENTEQUAL>) expressao()

}

/////////////////////////////////////////////////////////////CONDICIONAL IF
void cmdIf():
{}
{
    <IF> <LPARENTHESIS> expressao() <RPARENTHESIS> comando() (<ELSE> comando())?
}

/////////////////////////////////////////////////////////////COMANDO WHILE
void cmdWhile():
{}
{
    <WHILE> <LPARENTHESIS> expressao() <RPARENTHESIS> comando()
}

/////////////////////////////////////////////////////////////LAÇO FOR
void cmdFor():
{}
{
    <FOR> <LPARENTHESIS> <IDENTIFIER> atrib() <SEMICOLON> expressao() <SEMICOLON> <IDENTIFIER> atrib() <RPARENTHESIS> comando()
}

/////////////////////////////////////////////////////////////INTERRUPÇÃO DE LAÇO
void cmdStop():
{}
{
    <STOP><SEMICOLON>
}

/////////////////////////////////////////////////////////////SALTO DE ITERAÇÃO DE LAÇO
void cmdSkip():
{}
{
    <CONTINUE><SEMICOLON>
}

/////////////////////////////////////////////////////////////RETORNO DE SUBPROGRAMA
void cmdReturn():
{}
{
    <RETURN> (expressao())? <SEMICOLON>
}

/////////////////////////////////////////////////////////////CHAMADA DE PROCEDIMENTO
void cmdChamadaProc():
{}
{
    /*<IDENTIFIER>*/ <LPARENTHESIS> (expressao() (<COMMA> expressao())?)? <RPARENTHESIS> <SEMICOLON>
}

/////////////////////////////////////////////////////////////ENTRADA READ
void cmdRead():
{}
{
    <READ> <IDENTIFIER> variavel() <SEMICOLON>
}

/////////////////////////////////////////////////////////////SAIDA WRITE
void cmdWrite():
{}
{
    <WRITE> expressao() (<COMMA> expressao())* <SEMICOLON>
}

void variavel():
{}
{
    /*<IDENTIFIER>*/ (variavelPartTwo())?
}

void variavelPartTwo():
{}
{
    <LBRACKET> expressao() <RBRACKET>
}


//////////////////////////////////////////////////////////// EXPRESSÁO
void operadorTern():
{}
{
    expressao() <QUESTION> expressao() <COLON> expressao()
}

Expressao expressao() :
{
    Expressao exp = null;
}
{
    (exp = LogicalOR()) //asdasdsd
    {
        return exp;
    }
}

Expressao LogicalOR() :
{
    Expressao exp = null;
    Token op = null;
    List<Expressao> expList = new ArrayList<Expressao>();
    List<Operador> opList = new ArrayList<Operador>();
}
{
    ( (exp = LogicalAND()){expList.add(exp);} ( (op = <OR>){opList.add(Operador.getOp(op.kind));} ( exp = LogicalAND() ){expList.add(exp);} )*)
    {
        Expressao retExp = new Expressao(opList, expList);

        retExp.analiseSemantica();
        return retExp;
    }
}

Expressao LogicalAND() :
{
    Expressao exp = null;
    Token op = null;
    List<Expressao> expList = new ArrayList<Expressao>();
    List<Operador> opList = new ArrayList<Operador>();
}
{
    ( (exp = EqualityExpression()){expList.add(exp);} ( (op = <AND>){opList.add(Operador.getOp(op.kind));} ( exp = EqualityExpression() ){expList.add(exp);} )*)
    {
        Expressao retExp = new Expressao(opList, expList);

        retExp.analiseSemantica();
        return retExp;
    }
}

Expressao EqualityExpression() :
{
    Expressao exp = null;
    Token op = null;
    List<Expressao> expList = new ArrayList<Expressao>();
    List<Operador> opList = new ArrayList<Operador>();
}
{
    ( (exp = RelativeExpression()){{expList.add(exp);}} (( op = <EQUALS> | op = <DIFFERENT> ){opList.add(Operador.getOp(op.kind));} ( exp = RelativeExpression() ){expList.add(exp);} )*)
    {
        Expressao retExp = new Expressao(opList, expList);

        retExp.analiseSemantica();
        return retExp;
    }
}

Expressao RelativeExpression() :
{
    Expressao exp = null;
    Token op = null;
    List<Expressao> expList = new ArrayList<Expressao>();
    List<Operador> opList = new ArrayList<Operador>();
}
{
    ( (exp = AdditiveExpression()){expList.add(exp);} ( ( op = <MINUSEQUAL> | op = <SMALLER> | op = <BIGGEREQUAL> | op = <BIGGER> ){opList.add(Operador.getOp(op.kind));} ( exp = AdditiveExpression() ){expList.add(exp);} )*)
    {
        Expressao retExp = new Expressao(opList, expList);

        retExp.analiseSemantica();
        return retExp;
    }
}

Expressao AdditiveExpression() :
{
    Expressao exp = null;
    Token op = null;
    List<Expressao> expList = new ArrayList<Expressao>();
    List<Operador> opList = new ArrayList<Operador>();
}
{
    ( (exp = MultiplicativeExpression()){expList.add(exp);} ( ( op = <PLUS> | op = <MINUS> ){opList.add(Operador.getOp(op.kind));} ( exp = MultiplicativeExpression() ){expList.add(exp);} )*)
    {
        Expressao retExp = new Expressao(opList, expList);

        retExp.analiseSemantica();
        return retExp;
    }
}

Expressao MultiplicativeExpression() :
{
    Expressao exp = null;
    Token op = null;
    List<Expressao> expList = new ArrayList<Expressao>();
    List<Operador> opList = new ArrayList<Operador>();
}
{
    ( (exp = UnaryExpression()){expList.add(exp);} ( (op = <TIMES> | op = <DIVISION> | op = <PERCENT>){opList.add(Operador.getOp(op.kind));}  ( exp = UnaryExpression() ){expList.add(exp);} )*)
    {
        Expressao retExp = new Expressao(opList, expList);

        retExp.analiseSemantica();
        return retExp;
    }
}

Expressao UnaryExpression() :
{
    Expressao exp = new Expressao();
    Token tokenOp = null;
    Token elem = null;
    Operador op = null;
}
{
    (tokenOp = <NEGATION> | tokenOp = <MINUS> | tokenOp = <PLUS>)? (<LPARENTHESIS>  exp = expressao() <RPARENTHESIS> | exp = literal() | exp = identificavel())
    {
        Expressao retExp = new Expressao();
        if(tokenOp != null) retExp.opList.add(Operador.getOp(tokenOp.kind));
        retExp.expList.add(exp);

        retExp.analiseSemantica();
        return retExp;
    }
}

Expressao identificavel():
{
    Token token;
    Identificavel var = null;
    Expressao exp = null;
}
{
    (token = <IDENTIFIER>
    ((<LBRACKET>
    (exp = expressao())
    {
        if(exp.tipo != Tipo.INT) throw new RuntimeException("ERRO: Tipo de argumento incorreto. \r\nLine: " + token.beginLine);
    }
    <RBRACKET>) | cmdChamadaProc() )?)// APENAS CHAMADA DE FUNÇAO E CONSIDERADA EXPRESSAO
    {
        var = Compiler.pilhaDeEscopos.peek().buscarSimbolo(token);

        if(var==null)throw new RuntimeException("ERRO: Identificavel " + token.image + " nao instanciado. \r\nLine: " + token.beginLine);
        if(var.getTipo() == Tipo.VOID) throw new RuntimeException("ERRO: Subprograma " + token.image + " possui valor de retorno VOID. \r\nLine: " + token.beginLine);

        Expressao retExp = new Expressao();
        retExp.tipo = var.getTipo();
        return retExp;
    }
}


Expressao literal() :
{
    Expressao exp = new Expressao();
    Token t = token;
}
{
    (t = <NUMBER> | t = <BOOLEAN> | t = <WORD>)
    {
        exp.tipo = Tipo.getTipo(t.kind);
        //System.out.println("------------------>" + token.kind);
        return exp;
    }
}

//Token IDENTIFIER():
//{
//    Token t;
//    Identificavel ident = null;
//}
//{
//    ( t = <IDENTIFIER>)
//    {
//        ident = Compiler.pilhaDeEscopos.peek().buscarSimbolo(t);
//        if(ident==null)throw new RuntimeException("ERRO: Identificavel " + t.image + " nao instanciado. \r\nLine: " + t.beginLine);
//    }
//}
